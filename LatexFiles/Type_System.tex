JavaScript has a loose dynamic type system. This means that when you create a variable, you do not need to specify a type and the type of the variable can change during execution. Internally there is a type however and there are six internal types:
	%http://www.2ality.com/2013/09/types.html
	\begin{enumerate}
	\item Undefined
	\item Null
	\item Boolean
	\item String
	\item Number
	\item Object
	\end{enumerate}
\begin{lstlisting}[caption=Changing type of variable in Java]
int x = 1;
x = "hi";   // invalid, causes compiler error
\end{lstlisting}

\begin{lstlisting}[caption=Changing type of variable in JavaScript]
var x = 1;  // now x has Number type
x = "hi";   // now x has String type
x = {};     // now x has Object type
\end{lstlisting}
	If a variables type does not fit the operation that is applied on it, JavaScript will attempt to \emph{coerce} the variable into that type. This can be a source of great confusion and many bugs since it effectively masks errors. But it can make programming easier for beginners since they do not have to worry about bitness, converting input strings into numbers and some sorts of zero inputs.
\begin{lstlisting}[caption=Automatic type coercion]
2 + '10'   == '210' // Number coerced into String
2 * '10'   == 20    // String coerced into Number
true - 10  == -9    // Boolean coerced into Number
\end{lstlisting}

	In general, JavaScript tries to recover from errors made by the programmer, by avoiding throwing exceptions when encountering type errors. For example, when an uninitialized variable is used, there is no error but the variable is assigned the type Undefined and value undefined. This usually causes errors later in the program when the value is used. The errors are amplified by the fact that several normal operations are defined for the undefined value which further delays detection of the error.
\begin{lstlisting}[caption=Normal operations on undefined value]
1+undefined       == NaN
''+undefined      == 'undefined'
undefined && true == undefined
undefined || true == true
\end{lstlisting}	
This loose typing may be a disadvantage of the language when comparing the language to strongly typed languages such as Java. In Java the type system allows for static analysis of the code and many bugs are found at compile time. The true advantage of the loose type system only becomes apparent when the programmer uses the ability to augment types with new methods and properties at runtime.

\subsection{JavaScript Object and prototyping}
In Java, classes are static. There is no way to add a new method or property to an object after it is created. In JavaScript, there are no classes so all methods and properties are dynamically. This is a very powerful feature that may also be the cause of many bugs since properties and methods can be added and removed at any time during the programs execution.

\begin{lstlisting}[caption=JavaScript]
a = {} 	// empty object
a.property = "a"
a.method = function(){print("hello")}
\end{lstlisting}	

\begin{verbatim}

\end{verbatim}

\begin{lstlisting}[caption=Java]
class A {
	public String property;
	public void method(){
		print("hello");
	}
}
A a = new A();
a.property = "a";
a.property2 = "b"; // Invalid, was not specified in class
\end{lstlisting}	
%https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain
Another difference between Java and JavaScript is the way inheritance is implemented. In Java, a class can statically inherit methods and variables from a parent class. In JavaScript, there are no classes, only dynamic objects, so JavaScript uses another form of inheritance. All objects in a JavaScript execution are linked to a prototype object. The prototype describes the methods and properties assigned to the object and this is used by the dynamic type system to determine whether a particular object contains the method or property. This prototype can in turn be linked to a parent prototype, forming a prototype inheritance chain. To create an object and link it to another objects prototype,i.e. create an inheritance relation, JavaScript provides the Object.create() method as shown in listing~\ref{inheritance}.

\begin{lstlisting}[caption=Inheritance,label=inheritance]
var a = {prop:'hello'};
var b = Object.create(a); // b inherits from a
console.log(b.prop);      // prints 'hello'
a.prop = 'hi';
console.log(b.prop);      // prints 'hi'
b.prop = 'bye';           // now b.prop will override a.prop
console.log(b.prop)       // prints 'bye'
\end{lstlisting}	
This mechanism is more powerful but less robust than the Java class inheritance. Since the connection between the parent and child is dynamic, any changes in the parent object propagates to the child even after the child is created, as shown in listing~\ref{inheritance}. But on the other hand, changes in the child does not propagate to the parent and may break the link to the parent as shown in listing~\ref{inheritance} which can make this type of inheritance more error prone than classical inheritance. 

But the prototypal inheritance is more powerful than its classical counterpart. One example of this is that you can relatively easily emulate classical inheritance using prototypal inheritance but not vice versa.



\subsection{The function object}
One very powerful feature of JavaScript is the function object. In JavaScript, there is no dedicated function type but the function type inherits from Object. This means that functions can be treated as objects which makes the language considerably more powerful. Functions treated like objects enables the use of higher order functions, making JavaScript into \emph{both} an object oriented and functional language enabling very advanced concepts. A small example of this power is shown in listing~\ref{functionobject}

\begin{lstlisting}[caption=Inheritance,label=inheritance]
function map(f,array){
	for (var i=0;i<array.length; i++){
		array[i] = f(array[i]);
	}
	return array;
}
function add2(x){
	return x+2;
}
map(add2,[1,2,4]); // will return [3,4,6]
\end{lstlisting}	