JavaScript has a loose dynamic type system. This means that when you create a variable, you do not need to specify a type and the type of the variable can change during execution. Internally there is a type however and there are six internal types:
	%http://www.2ality.com/2013/09/types.html
	\begin{enumerate}
	\item Undefined
	\item Null
	\item Boolean
	\item String
	\item Number
	\item Object
	\end{enumerate}
\begin{lstlisting}[caption=Changing type of variable in Java]
int x = 1;
x = "hi";   // invalid, causes compiler error
\end{lstlisting}

\begin{lstlisting}[caption=Changing type of variable in JavaScript]
var x = 1;  // now x has Number type
x = "hi";   // now x has String type
x = {};     // now x has Object type
\end{lstlisting}
	If a variables type does not fit the operation that is applied on it, JavaScript will attempt to \emph{coerce} the variable into that type. This can be a source of great confusion and many bugs since it effectively masks errors. But it can make programming easier for beginners since they do not have to worry about bitness, converting input strings into numbers and some sorts of zero inputs.
\begin{lstlisting}[caption=Automatic type coercion]
2 + '10'   == '210' // Number coerced into String
2 * '10'   == 20    // String coerced into Number
true - 10  == -9    // Boolean coerced into Number
\end{lstlisting}

	In general, JavaScript tries to recover from errors made by the programmer, by avoiding throwing exceptions when encountering type errors. For example, when an uninitialized variable is used, there is no error but the variable is assigned the type Undefined and value undefined. This usually causes errors later in the program when the value is used. The errors are amplified by the fact that several normal operations are defined for the undefined value which further delays detection of the error.
\begin{lstlisting}[caption=Normal operations on undefined value]
1+undefined       == NaN
''+undefined      == 'undefined'
undefined && true == undefined
undefined || true == true
\end{lstlisting}	
This loose typing may be a disadvantage of the language when comparing the language to strongly typed languages such as Java. In Java the type system allows for static analysis of the code and many bugs are found at compile time. The true advantage of the loose type system only becomes apparent when the programmer uses the ability to augment types with new methods and properties at runtime.

\subsection{JavaScript Object and prototyping}
In Java, classes are static. There is no way to add a new method or property to an object after it is created. In JavaScript, there are no classes so all methods and properties are dynamically. This is a very powerful feature that may also be the cause of many bugs since properties and methods can be added and removed at any time during the programs execution.

\begin{lstlisting}[caption=JavaScript]
a = {} 	// empty object
a.property = "a"
a.method = function(){print("hello")}
\end{lstlisting}	

\begin{verbatim}

\end{verbatim}

\begin{verbatim}
Java
class A {
	public String property;
	public void method(){
		print("hello");
	}
}
A a = new A();
a.property = "a";
a.property2 = "b"; // Invalid, was not specified in class
\end{verbatim}
%https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain
Another difference between Java and JavaScript is the way inheritance is implemented. In Java, a class can statically inherit methods and variables from a parent class. In JavaScript, there are no classes, only dynamic objects, so JavaScript uses another form of inheritance. All objects in a JavaScript execution are linked to a prototype object. The prototype describes the methods and properties assigned to the object and this is used by the dynamic type system to determine whether 
	One feature
	- inheritance
	- loose typing
	- dynamic

